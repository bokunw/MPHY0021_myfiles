For the part without numpy:

When the iteration number is relatively low, e.g. below 10, the time to produce the tree are very small. But as the iteration number goes higher, the time taken to produce the tree increases exponentially. This is to be expected since as the iteration number is higher, more splitting point will be produced hence there are more calculation to be done for  where the branches should be, and it will take longer for the code to run. The time difference of running the code at 18th and 19th iteration would be drastically greater then the time difference of running the code at 11th and 12th ieration. And the time difference would be even more drastically greater for higher adjacent number of iterations i.e. the graidient of this time vs iteration numbers relationship increases greatly over iteration number. 


Comparing numpy solution with the solution using "append":

As seen from the figure with the performances of both methods plotted, the numpy solution is way more efficient and quicker then the solution using append.They both have an exponential shape where the higher the iteration number, the run time increase drastically, but the numpy solution stay almostly flat for a longer time and when it does starting to increase, the magnitude of increase is much smaller compare to the solution with append at the same number of iteration. This is because the numpy array operations are written based on C-based language which are faster, compare to the solution using append which use a for loop to calculate each new points in python. The numpy solution got rid of the inner for loop in the original code and replace it with numpy array operations instead. The performance comparison code iterate through two solutions with a different iteration number, with a higher iteration number for numpy solution. This is just because it takes too long for the append solution to run when the iteration number is high. 